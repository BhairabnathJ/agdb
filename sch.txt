

---

## What I Need You To Build

### 1. SQLite Database on SD Card

**Database location:** `/sd/agriscan.db`

**Tables needed:**

```sql
-- Main sensor readings + physics calculations
CREATE TABLE samples (
    timestamp INTEGER PRIMARY KEY,  -- Unix timestamp (seconds)
    raw_adc INTEGER,                -- Raw sensor value
    temp_c REAL,                    -- Temperature (°C)
    theta REAL,                     -- Volumetric water content (m³/m³)
    theta_fc REAL,                  -- Auto-calibrated field capacity
    theta_refill REAL,              -- Auto-calibrated refill point
    psi_kpa REAL,                   -- Matric potential (kPa)
    aw_mm REAL,                     -- Available water (mm)
    fraction_depleted REAL,         -- Depletion (0-1)
    drying_rate REAL,               -- dθ/dt (m³/m³/hr)
    regime TEXT,                    -- 'wetting'|'drainage'|'drydown'|'stable'
    status TEXT,                    -- 'REFILL'|'MONITOR'|'OPTIMAL'|'FULL'
    urgency TEXT,                   -- 'none'|'low'|'medium'|'high'
    confidence REAL,                -- Calibration confidence (0-1)
    qc_valid INTEGER,               -- 0/1 boolean
    seq INTEGER                     -- Sequence number
);

CREATE INDEX idx_timestamp ON samples(timestamp);

-- Detected events (wetting/drying)
CREATE TABLE events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ts_start INTEGER,
    ts_end INTEGER,
    event_type TEXT,    -- 'wetting'|'drainage'|'drydown'
    delta_theta REAL,
    metadata_json TEXT
);

-- Calibration history
CREATE TABLE calibration (
    version INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER,
    state TEXT,         -- State machine state
    theta_fc REAL,
    theta_refill REAL,
    n_events INTEGER,
    confidence REAL,
    params_json TEXT    -- Full dynamics parameters as JSON
);
```

**Storage format notes:**
- Store VWC as REAL (no scaling) - SQLite handles precision
- Use INTEGER for timestamps (Unix epoch)
- Store complex data as JSON in TEXT fields

---

### 2. C++ Code for ESP32 Database Operations

**Requirements:**
- Use `sqlite3` library for ESP32 (available via PlatformIO)
- Initialize database on SD card at `/sd/agriscan.db`
- **Batch writes:** Collect 6 samples (1 hour) in RAM, write in single transaction
- **WAL mode** for crash safety
- Prepared statements for performance

**Core functions I need:**

```cpp
// db_manager.h
#ifndef DB_MANAGER_H
#define DB_MANAGER_H

#include <sqlite3.h>
#include <vector>

struct SampleData {
    time_t timestamp;
    int raw_adc;
    float temp_c;
    float theta;
    float theta_fc;
    float theta_refill;
    float psi_kpa;
    float aw_mm;
    float fraction_depleted;
    float drying_rate;
    String regime;
    String status;
    String urgency;
    float confidence;
    bool qc_valid;
    int seq;
};

class DBManager {
public:
    DBManager(const char* dbPath);
    ~DBManager();
    
    bool init();
    bool writeSampleBatch(std::vector<SampleData>& samples);
    SampleData getLatestSample();
    std::vector<SampleData> getRecentSamples(int n);
    std::vector<SampleData> getSamplesInRange(time_t start, time_t end);
    
    bool writeCalibration(String state, float fc, float refill, int n_events, float conf, String params_json);
    String getCalibrationJSON();
    
    bool cleanOldData(int daysToKeep);
    
private:
    sqlite3* db;
    const char* dbPath;
    sqlite3_stmt* insertStmt;
    
    bool executeSQL(const char* sql);
    bool prepareStatements();
};

#endif
```

**Implementation (db_manager.cpp):**
- Handle SD card initialization
- Open database with WAL mode
- Create tables if they don't exist
- Prepared statements for inserts
- Transaction handling for batch writes
- Error handling with Serial.println for debugging

---

### 3. Data Flow Architecture (Critical!)

Here's how data should flow through the system:

```
┌─────────────────────────────────────────────────────────┐
│                    ESP32 System                          │
└─────────────────────────────────────────────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
  ┌─────▼──────┐   ┌──────▼──────┐   ┌─────▼──────┐
  │  Sensors   │   │ physics.js  │   │  SQLite    │
  │ (C++ loop) │   │(on SD card) │   │(on SD card)│
  └─────┬──────┘   └──────▲──────┘   └─────▲──────┘
        │                 │                 │
        │  Every 10min    │                 │
        │                 │                 │
        └─────────────────┘                 │
                                            │
  ┌─────────────────────────────────────────┘
  │
  │  ESP32 reads sensors → Calls physics.js via Duktape/JerryScript
  │  Physics.js returns: { theta, status, confidence, ... }
  │  ESP32 stores to batch buffer (RAM)
  │  Every 6 samples → Write batch to SQLite
  │
  ▼
┌───────────────────────────────────────┐
│         microSD Card Layout           │
├───────────────────────────────────────┤
│ /sd/                                  │
│   ├── agriscan.db       (SQLite)      │
│   ├── agriscan.db-wal   (WAL file)    │
│   ├── agriscan.db-shm   (Shared mem)  │
│   ├── www/              (Dashboard)   │
│   │   ├── index.html                  │
│   │   ├── style.css                   │
│   │   ├── app.js                      │
│   ├── physics.js        (Engine)      │
│   └── config.json       (Settings)    │
└───────────────────────────────────────┘
```

**Key points:**
1. **physics.js lives on SD card** (not in ESP32 flash)
2. **ESP32 loads and runs physics.js** using JavaScript engine (Duktape or JerryScript)
3. **Results go to RAM batch buffer** (6 samples = ~1KB)
4. **Every hour, batch writes to SQLite** (reduces SD wear)
5. **Dashboard served from SD** (ESP32 reads files, serves via HTTP)

---

### 4. JavaScript Execution on ESP32

**Two options - tell me which to implement:**

**Option A: Duktape** (recommended)
```cpp
// Include Duktape
#include "duktape.h"

// Load physics.js from SD
File physicsFile = SD.open("/sd/physics.js");
String physicsCode = physicsFile.readString();

// Create JS context
duk_context *ctx = duk_create_heap_default();

// Load physics.js
duk_eval_string(ctx, physicsCode.c_str());

// Call physics engine
char jsCall[256];
sprintf(jsCall, "engine.processSensorReading(%d, %.2f, %ld)", raw, temp, timestamp);
duk_eval_string(ctx, jsCall);

// Get result object
duk_get_prop_string(ctx, -1, "theta");
float theta = (float)duk_get_number(ctx, -1);
// ... extract other fields
```

**Option B: Port physics.js to C++**
- Translate JavaScript to C++ (I can help with this)
- No JS engine needed
- Smaller memory footprint
- Slightly more work upfront

**Which do you prefer?** (I'll code the full implementation either way)

---

### 5. Dashboard API Endpoints (ESP32 Web Server)

ESP32 serves these endpoints by querying SQLite:

```cpp
// In your ESP32 web server setup:

server.on("/api/current", HTTP_GET, [](AsyncWebServerRequest *request){
    SampleData latest = dbManager.getLatestSample();
    
    String json = "{";
    json += "\"timestamp\":" + String(latest.timestamp) + ",";
    json += "\"theta\":" + String(latest.theta, 4) + ",";
    json += "\"temp_c\":" + String(latest.temp_c, 2) + ",";
    json += "\"status\":\"" + latest.status + "\",";
    json += "\"recommendation\":\"" + getRecommendation(latest.status) + "\",";
    json += "\"confidence\":" + String(latest.confidence, 2);
    json += "}";
    
    request->send(200, "application/json", json);
});

server.on("/api/series", HTTP_GET, [](AsyncWebServerRequest *request){
    // Get time range from query params
    long start = request->getParam("start")->value().toInt();
    long end = request->getParam("end")->value().toInt();
    
    std::vector<SampleData> samples = dbManager.getSamplesInRange(start, end);
    
    // Build JSON array
    String json = "[";
    for (int i = 0; i < samples.size(); i++) {
        if (i > 0) json += ",";
        json += sampleToJSON(samples[i]);
    }
    json += "]";
    
    request->send(200, "application/json", json);
});

server.on("/api/calibration", HTTP_GET, [](AsyncWebServerRequest *request){
    String json = dbManager.getCalibrationJSON();
    request->send(200, "application/json", json);
});
```

**Dashboard JavaScript (app.js on SD card):**

```javascript
// Fetch current status
async function updateCurrentStatus() {
    const response = await fetch('/api/current');
    const data = await response.json();
    
    document.getElementById('moisture').textContent = (data.theta * 100).toFixed(1) + '%';
    document.getElementById('temp').textContent = data.temp_c.toFixed(1) + '°C';
    document.getElementById('status').textContent = data.status;
    document.getElementById('confidence').textContent = (data.confidence * 100).toFixed(0) + '%';
    
    updateLEDIndicator(data.status);
}

// Fetch time series for chart
async function updateChart() {
    const now = Math.floor(Date.now() / 1000);
    const yesterday = now - (24 * 3600);
    
    const response = await fetch(`/api/series?start=${yesterday}&end=${now}`);
    const data = await response.json();
    
    // Render chart (use Chart.js or simple canvas)
    renderMoistureChart(data);
}

// Update every 60 seconds
setInterval(updateCurrentStatus, 60000);
setInterval(updateChart, 300000);  // 5 minutes
```

---

### 6. Mock Data Simulator (For Testing Without Hardware)

**Admin endpoint to inject test data:**

```cpp
server.on("/admin/inject", HTTP_POST, [](AsyncWebServerRequest *request){
    // Parse JSON body
    String body = request->getBody();
    
    // Inject sample into database
    SampleData sample;
    sample.timestamp = time(nullptr);
    sample.raw_adc = extractJSON(body, "raw");
    sample.temp_c = extractJSON(body, "temp");
    // ... etc
    
    std::vector<SampleData> batch = {sample};
    dbManager.writeSampleBatch(batch);
    
    request->send(200, "text/plain", "Sample injected");
});
```

**Admin UI (admin.html):**
```html
<div id="simulator">
    <h2>Data Simulator</h2>
    <label>Moisture %: <input type="range" id="moisture" min="0" max="100" value="50"></label>
    <label>Temperature: <input type="number" id="temp" value="25"></label>
    <button onclick="injectSample()">Inject Sample</button>
    
    <h3>Quick Scenarios</h3>
    <button onclick="simulateRain()">Simulate Rain</button>
    <button onclick="simulateDrought()">Simulate Drought</button>
</div>

<script>
function injectSample() {
    const moisture = document.getElementById('moisture').value / 100;
    const temp = parseFloat(document.getElementById('temp').value);
    
    fetch('/admin/inject', {
        method: 'POST',
        body: JSON.stringify({
            raw: moistureToRaw(moisture),
            temp: temp
        })
    });
}

function simulateRain() {
    // Inject rapid moisture increase
    let moisture = 0.25;
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            injectDataPoint(moisture + (i * 0.05), 25);
        }, i * 60000);  // 1 minute intervals
    }
}
</script>
```

---

## What I Need From You

Please provide **complete, working code** for:

1. ✅ **SQLite schema** (CREATE TABLE statements)
2. ✅ **db_manager.cpp/.h** (full implementation with error handling)
3. ✅ **ESP32 main loop integration** (how to call physics.js + write to DB)
4. ✅ **Web server endpoints** (/api/current, /api/series, /api/calibration)
5. ✅ **Dashboard HTML/CSS/JS** (simple, clean UI)
6. ✅ **Mock data simulator** (admin interface)
7. ✅ **SD card file structure** (exact directory layout)

**Constraints:**
- ESP32: 4MB flash, 520KB RAM
- SD card: 8GB minimum, Class 10
- Database must survive power loss (WAL mode)
- Queries must be fast (<100ms for dashboard)

**Tell me which JavaScript engine to use** (Duktape or port to C++) and I'll give you the full implementation.

---

## Example Physics.js Output (For Reference)

```javascript
{
  timestamp: 1737753600,
  raw: 650,
  temp_c: 25.0,
  theta: 0.245,
  theta_fc: 0.320,
  theta_refill: 0.220,
  psi_kPa: 12.0,
  Se: 0.65,
  TAW_mm: 42.0,
  AW_mm: 25.0,
  fractionDepleted: 0.40,
  dryingRate_per_hr: -0.0008,
  regime: 'drydown',
  status: 'OPTIMAL',
  recommendation: 'Soil moisture optimal',
  urgency: 'low',
  qc_valid: true,
  confidence: 0.75
}
```

Your code should extract these fields and store them in SQLite efficiently.

---

**Start with the SQLite schema and db_manager.cpp implementation, then we'll tackle the web server and dashboard integration.**